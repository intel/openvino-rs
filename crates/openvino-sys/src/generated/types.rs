/* automatically generated by rust-bindgen 0.70.1 */

#[doc = "!< SUCCESS"]
pub const ov_status_e_OK: ov_status_e = 0;
#[doc = "!< GENERAL_ERROR"]
pub const ov_status_e_GENERAL_ERROR: ov_status_e = -1;
#[doc = "!< NOT_IMPLEMENTED"]
pub const ov_status_e_NOT_IMPLEMENTED: ov_status_e = -2;
#[doc = "!< NETWORK_NOT_LOADED"]
pub const ov_status_e_NETWORK_NOT_LOADED: ov_status_e = -3;
#[doc = "!< PARAMETER_MISMATCH"]
pub const ov_status_e_PARAMETER_MISMATCH: ov_status_e = -4;
#[doc = "!< NOT_FOUND"]
pub const ov_status_e_NOT_FOUND: ov_status_e = -5;
#[doc = "!< OUT_OF_BOUNDS"]
pub const ov_status_e_OUT_OF_BOUNDS: ov_status_e = -6;
#[doc = "!< UNEXPECTED"]
pub const ov_status_e_UNEXPECTED: ov_status_e = -7;
#[doc = "!< REQUEST_BUSY"]
pub const ov_status_e_REQUEST_BUSY: ov_status_e = -8;
#[doc = "!< RESULT_NOT_READY"]
pub const ov_status_e_RESULT_NOT_READY: ov_status_e = -9;
#[doc = "!< NOT_ALLOCATED"]
pub const ov_status_e_NOT_ALLOCATED: ov_status_e = -10;
#[doc = "!< INFER_NOT_STARTED"]
pub const ov_status_e_INFER_NOT_STARTED: ov_status_e = -11;
#[doc = "!< NETWORK_NOT_READ"]
pub const ov_status_e_NETWORK_NOT_READ: ov_status_e = -12;
#[doc = "!< INFER_CANCELLED"]
pub const ov_status_e_INFER_CANCELLED: ov_status_e = -13;
#[doc = "!< INVALID_C_PARAM"]
pub const ov_status_e_INVALID_C_PARAM: ov_status_e = -14;
#[doc = "!< UNKNOWN_C_ERROR"]
pub const ov_status_e_UNKNOWN_C_ERROR: ov_status_e = -15;
#[doc = "!< NOT_IMPLEMENT_C_METHOD"]
pub const ov_status_e_NOT_IMPLEMENT_C_METHOD: ov_status_e = -16;
#[doc = "!< UNKNOW_EXCEPTION"]
pub const ov_status_e_UNKNOW_EXCEPTION: ov_status_e = -17;
#[doc = " @enum ov_status_e\n @ingroup ov_base_c_api\n @brief This enum contains codes for all possible return values of the interface functions"]
pub type ov_status_e = ::std::os::raw::c_int;
#[doc = "!< Undefined element type"]
pub const ov_element_type_e_UNDEFINED: ov_element_type_e = 0;
#[doc = "!< Dynamic element type"]
pub const ov_element_type_e_DYNAMIC: ov_element_type_e = 1;
pub const ov_element_type_e_OV_BOOLEAN: ov_element_type_e = 2;
#[doc = "!< bf16 element type"]
pub const ov_element_type_e_BF16: ov_element_type_e = 3;
#[doc = "!< f16 element type"]
pub const ov_element_type_e_F16: ov_element_type_e = 4;
#[doc = "!< f32 element type"]
pub const ov_element_type_e_F32: ov_element_type_e = 5;
#[doc = "!< f64 element type"]
pub const ov_element_type_e_F64: ov_element_type_e = 6;
#[doc = "!< i4 element type"]
pub const ov_element_type_e_I4: ov_element_type_e = 7;
#[doc = "!< i8 element type"]
pub const ov_element_type_e_I8: ov_element_type_e = 8;
#[doc = "!< i16 element type"]
pub const ov_element_type_e_I16: ov_element_type_e = 9;
#[doc = "!< i32 element type"]
pub const ov_element_type_e_I32: ov_element_type_e = 10;
#[doc = "!< i64 element type"]
pub const ov_element_type_e_I64: ov_element_type_e = 11;
#[doc = "!< binary element type"]
pub const ov_element_type_e_U1: ov_element_type_e = 12;
#[doc = "!< u4 element type"]
pub const ov_element_type_e_U4: ov_element_type_e = 13;
#[doc = "!< u8 element type"]
pub const ov_element_type_e_U8: ov_element_type_e = 14;
#[doc = "!< u16 element type"]
pub const ov_element_type_e_U16: ov_element_type_e = 15;
#[doc = "!< u32 element type"]
pub const ov_element_type_e_U32: ov_element_type_e = 16;
#[doc = "!< u64 element type"]
pub const ov_element_type_e_U64: ov_element_type_e = 17;
#[doc = "!< nf4 element type"]
pub const ov_element_type_e_NF4: ov_element_type_e = 18;
#[doc = "!< f8e4m3 element type"]
pub const ov_element_type_e_F8E4M3: ov_element_type_e = 19;
#[doc = "!< f8e5m2 element type"]
pub const ov_element_type_e_F8E5M3: ov_element_type_e = 20;
#[doc = " @enum ov_element_type_e\n @ingroup ov_base_c_api\n @brief This enum contains codes for element type."]
pub type ov_element_type_e = ::std::os::raw::c_uint;
#[doc = " @struct ov_dimension\n @ingroup ov_dimension_c_api\n @brief This is a structure interface equal to ov::Dimension"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_dimension {
    #[doc = "!< The lower inclusive limit for the dimension."]
    pub min: i64,
    #[doc = "!< The upper inclusive limit for the dimension."]
    pub max: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_dimension"][::std::mem::size_of::<ov_dimension>() - 16usize];
    ["Alignment of ov_dimension"][::std::mem::align_of::<ov_dimension>() - 8usize];
    ["Offset of field: ov_dimension::min"][::std::mem::offset_of!(ov_dimension, min) - 0usize];
    ["Offset of field: ov_dimension::max"][::std::mem::offset_of!(ov_dimension, max) - 8usize];
};
#[doc = " @struct ov_dimension\n @ingroup ov_dimension_c_api\n @brief This is a structure interface equal to ov::Dimension"]
pub type ov_dimension_t = ov_dimension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_layout {
    _unused: [u8; 0],
}
#[doc = " @struct ov_layout_t\n @ingroup ov_layout_c_api\n @brief type define ov_layout_t from ov_layout"]
pub type ov_layout_t = ov_layout;
#[doc = " @struct ov_rank_t\n @ingroup ov_rank_c_api\n @brief type define ov_rank_t from ov_dimension_t"]
pub type ov_rank_t = ov_dimension_t;
#[doc = " @struct ov_shape_t\n @ingroup ov_shape_c_api\n @brief Reprents a static shape."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_shape_t {
    #[doc = "!< the rank of shape"]
    pub rank: i64,
    #[doc = "!< the dims of shape"]
    pub dims: *mut i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_shape_t"][::std::mem::size_of::<ov_shape_t>() - 16usize];
    ["Alignment of ov_shape_t"][::std::mem::align_of::<ov_shape_t>() - 8usize];
    ["Offset of field: ov_shape_t::rank"][::std::mem::offset_of!(ov_shape_t, rank) - 0usize];
    ["Offset of field: ov_shape_t::dims"][::std::mem::offset_of!(ov_shape_t, dims) - 8usize];
};
#[doc = " @struct ov_partial_shape\n @ingroup ov_partial_shape_c_api\n @brief It represents a shape that may be partially or totally dynamic.\n A PartialShape may have:\n Dynamic rank. (Informal notation: `?`)\n Static rank, but dynamic dimensions on some or all axes.\n     (Informal notation examples: `{1,2,?,4}`, `{?,?,?}`, `{-1,-1,-1}`)\n Static rank, and static dimensions on all axes.\n     (Informal notation examples: `{1,2,3,4}`, `{6}`, `{}`)\n\n An interface to make user can initialize ov_partial_shape_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_partial_shape {
    #[doc = "!< The rank"]
    pub rank: ov_rank_t,
    #[doc = "!< The dimension"]
    pub dims: *mut ov_dimension_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_partial_shape"][::std::mem::size_of::<ov_partial_shape>() - 24usize];
    ["Alignment of ov_partial_shape"][::std::mem::align_of::<ov_partial_shape>() - 8usize];
    ["Offset of field: ov_partial_shape::rank"]
        [::std::mem::offset_of!(ov_partial_shape, rank) - 0usize];
    ["Offset of field: ov_partial_shape::dims"]
        [::std::mem::offset_of!(ov_partial_shape, dims) - 16usize];
};
#[doc = " @struct ov_partial_shape\n @ingroup ov_partial_shape_c_api\n @brief It represents a shape that may be partially or totally dynamic.\n A PartialShape may have:\n Dynamic rank. (Informal notation: `?`)\n Static rank, but dynamic dimensions on some or all axes.\n     (Informal notation examples: `{1,2,?,4}`, `{?,?,?}`, `{-1,-1,-1}`)\n Static rank, and static dimensions on all axes.\n     (Informal notation examples: `{1,2,3,4}`, `{6}`, `{}`)\n\n An interface to make user can initialize ov_partial_shape_t"]
pub type ov_partial_shape_t = ov_partial_shape;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_output_const_port {
    _unused: [u8; 0],
}
#[doc = " @struct ov_output_const_port_t\n @ingroup ov_node_c_api\n @brief type define ov_output_const_port_t from ov_output_const_port"]
pub type ov_output_const_port_t = ov_output_const_port;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_output_port {
    _unused: [u8; 0],
}
#[doc = " @struct ov_output_port_t\n @ingroup ov_node_c_api\n @brief type define ov_output_port_t from ov_output_port"]
pub type ov_output_port_t = ov_output_port;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_tensor {
    _unused: [u8; 0],
}
#[doc = " @struct ov_tensor_t\n @ingroup ov_tensor_c_api\n @brief type define ov_tensor_t from ov_tensor"]
pub type ov_tensor_t = ov_tensor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_infer_request {
    _unused: [u8; 0],
}
#[doc = " @struct ov_infer_request_t\n @ingroup ov_infer_request_c_api\n @brief type define ov_infer_request_t from ov_infer_request"]
pub type ov_infer_request_t = ov_infer_request;
#[doc = " @struct ov_callback_t\n @ingroup ov_infer_request_c_api\n @brief Completion callback definition about the function and args"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_callback_t {
    #[doc = "!< The callback func"]
    pub callback_func:
        ::std::option::Option<unsafe extern "C" fn(args: *mut ::std::os::raw::c_void)>,
    #[doc = "!< The args of callback func"]
    pub args: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_callback_t"][::std::mem::size_of::<ov_callback_t>() - 16usize];
    ["Alignment of ov_callback_t"][::std::mem::align_of::<ov_callback_t>() - 8usize];
    ["Offset of field: ov_callback_t::callback_func"]
        [::std::mem::offset_of!(ov_callback_t, callback_func) - 0usize];
    ["Offset of field: ov_callback_t::args"][::std::mem::offset_of!(ov_callback_t, args) - 8usize];
};
#[doc = " @struct ov_ProfilingInfo_t\n @ingroup ov_infer_request_c_api\n @brief Store profiling info data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_profiling_info_t {
    #[doc = "!< status"]
    pub status: ov_profiling_info_t_Status,
    #[doc = "!< The absolute time, in microseconds, that the node ran (in total)."]
    pub real_time: i64,
    #[doc = "!< The net host CPU time that the node ran."]
    pub cpu_time: i64,
    #[doc = "!< Name of a node."]
    pub node_name: *const ::std::os::raw::c_char,
    #[doc = "!< Execution type of a unit."]
    pub exec_type: *const ::std::os::raw::c_char,
    #[doc = "!< Node type."]
    pub node_type: *const ::std::os::raw::c_char,
}
#[doc = "!< A node is not executed."]
pub const ov_profiling_info_t_Status_NOT_RUN: ov_profiling_info_t_Status = 0;
#[doc = "!< A node is optimized out during graph optimization phase."]
pub const ov_profiling_info_t_Status_OPTIMIZED_OUT: ov_profiling_info_t_Status = 1;
#[doc = "!< A node is executed."]
pub const ov_profiling_info_t_Status_EXECUTED: ov_profiling_info_t_Status = 2;
pub type ov_profiling_info_t_Status = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_profiling_info_t"][::std::mem::size_of::<ov_profiling_info_t>() - 48usize];
    ["Alignment of ov_profiling_info_t"][::std::mem::align_of::<ov_profiling_info_t>() - 8usize];
    ["Offset of field: ov_profiling_info_t::status"]
        [::std::mem::offset_of!(ov_profiling_info_t, status) - 0usize];
    ["Offset of field: ov_profiling_info_t::real_time"]
        [::std::mem::offset_of!(ov_profiling_info_t, real_time) - 8usize];
    ["Offset of field: ov_profiling_info_t::cpu_time"]
        [::std::mem::offset_of!(ov_profiling_info_t, cpu_time) - 16usize];
    ["Offset of field: ov_profiling_info_t::node_name"]
        [::std::mem::offset_of!(ov_profiling_info_t, node_name) - 24usize];
    ["Offset of field: ov_profiling_info_t::exec_type"]
        [::std::mem::offset_of!(ov_profiling_info_t, exec_type) - 32usize];
    ["Offset of field: ov_profiling_info_t::node_type"]
        [::std::mem::offset_of!(ov_profiling_info_t, node_type) - 40usize];
};
#[doc = " @struct ov_profiling_info_list_t\n @ingroup ov_infer_request_c_api\n @brief A list of profiling info data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_profiling_info_list_t {
    #[doc = "!< The list of ov_profilling_info_t"]
    pub profiling_infos: *mut ov_profiling_info_t,
    #[doc = "!< The list size"]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_profiling_info_list_t"]
        [::std::mem::size_of::<ov_profiling_info_list_t>() - 16usize];
    ["Alignment of ov_profiling_info_list_t"]
        [::std::mem::align_of::<ov_profiling_info_list_t>() - 8usize];
    ["Offset of field: ov_profiling_info_list_t::profiling_infos"]
        [::std::mem::offset_of!(ov_profiling_info_list_t, profiling_infos) - 0usize];
    ["Offset of field: ov_profiling_info_list_t::size"]
        [::std::mem::offset_of!(ov_profiling_info_list_t, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_model {
    _unused: [u8; 0],
}
#[doc = " @struct ov_model_t\n @ingroup ov_model_c_api\n @brief type define ov_model_t from ov_model"]
pub type ov_model_t = ov_model;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_remote_context {
    _unused: [u8; 0],
}
pub type ov_remote_context_t = ov_remote_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_compiled_model {
    _unused: [u8; 0],
}
#[doc = " @struct ov_compiled_model_t\n @ingroup ov_compiled_model_c_api\n @brief type define ov_compiled_model_t from ov_compiled_model"]
pub type ov_compiled_model_t = ov_compiled_model;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_core {
    _unused: [u8; 0],
}
#[doc = " @struct ov_core_t\n @ingroup ov_core_c_api\n @brief type define ov_core_t from ov_core"]
pub type ov_core_t = ov_core;
#[doc = " @struct ov_version\n @ingroup ov_core_c_api\n @brief Represents OpenVINO version information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_version {
    #[doc = "!< A string representing OpenVINO version"]
    pub buildNumber: *const ::std::os::raw::c_char,
    #[doc = "!< A string representing OpenVINO description"]
    pub description: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_version"][::std::mem::size_of::<ov_version>() - 16usize];
    ["Alignment of ov_version"][::std::mem::align_of::<ov_version>() - 8usize];
    ["Offset of field: ov_version::buildNumber"]
        [::std::mem::offset_of!(ov_version, buildNumber) - 0usize];
    ["Offset of field: ov_version::description"]
        [::std::mem::offset_of!(ov_version, description) - 8usize];
};
#[doc = " @struct ov_version\n @ingroup ov_core_c_api\n @brief Represents OpenVINO version information"]
pub type ov_version_t = ov_version;
#[doc = " @struct ov_core_version\n @ingroup ov_core_c_api\n @brief  Represents version information that describes device and ov runtime library"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_core_version_t {
    #[doc = "!< A device name"]
    pub device_name: *const ::std::os::raw::c_char,
    #[doc = "!< Version"]
    pub version: ov_version_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_core_version_t"][::std::mem::size_of::<ov_core_version_t>() - 24usize];
    ["Alignment of ov_core_version_t"][::std::mem::align_of::<ov_core_version_t>() - 8usize];
    ["Offset of field: ov_core_version_t::device_name"]
        [::std::mem::offset_of!(ov_core_version_t, device_name) - 0usize];
    ["Offset of field: ov_core_version_t::version"]
        [::std::mem::offset_of!(ov_core_version_t, version) - 8usize];
};
#[doc = " @struct ov_core_version_list\n @ingroup ov_core_c_api\n @brief  Represents version information that describes all devices and ov runtime library"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_core_version_list_t {
    #[doc = "!< An array of device versions"]
    pub versions: *mut ov_core_version_t,
    #[doc = "!< A number of versions in the array"]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_core_version_list_t"][::std::mem::size_of::<ov_core_version_list_t>() - 16usize];
    ["Alignment of ov_core_version_list_t"]
        [::std::mem::align_of::<ov_core_version_list_t>() - 8usize];
    ["Offset of field: ov_core_version_list_t::versions"]
        [::std::mem::offset_of!(ov_core_version_list_t, versions) - 0usize];
    ["Offset of field: ov_core_version_list_t::size"]
        [::std::mem::offset_of!(ov_core_version_list_t, size) - 8usize];
};
#[doc = " @struct ov_available_devices_t\n @ingroup ov_core_c_api\n @brief Represent all available devices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_available_devices_t {
    #[doc = "!< devices' name"]
    pub devices: *mut *mut ::std::os::raw::c_char,
    #[doc = "!< devices' number"]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ov_available_devices_t"][::std::mem::size_of::<ov_available_devices_t>() - 16usize];
    ["Alignment of ov_available_devices_t"]
        [::std::mem::align_of::<ov_available_devices_t>() - 8usize];
    ["Offset of field: ov_available_devices_t::devices"]
        [::std::mem::offset_of!(ov_available_devices_t, devices) - 0usize];
    ["Offset of field: ov_available_devices_t::size"]
        [::std::mem::offset_of!(ov_available_devices_t, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_prepostprocessor {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_prepostprocessor_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_prepostprocessor_t from ov_preprocess_prepostprocessor"]
pub type ov_preprocess_prepostprocessor_t = ov_preprocess_prepostprocessor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_input_info {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_input_info_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_input_info_t from ov_preprocess_input_info"]
pub type ov_preprocess_input_info_t = ov_preprocess_input_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_input_tensor_info {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_input_tensor_info_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_input_tensor_info_t from ov_preprocess_input_tensor_info"]
pub type ov_preprocess_input_tensor_info_t = ov_preprocess_input_tensor_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_output_info {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_output_info_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_output_info_t from ov_preprocess_output_info"]
pub type ov_preprocess_output_info_t = ov_preprocess_output_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_output_tensor_info {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_output_tensor_info_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_output_tensor_info_t from ov_preprocess_output_tensor_info"]
pub type ov_preprocess_output_tensor_info_t = ov_preprocess_output_tensor_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_input_model_info {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_input_model_info_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_input_model_info_t from ov_preprocess_input_model_info"]
pub type ov_preprocess_input_model_info_t = ov_preprocess_input_model_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ov_preprocess_preprocess_steps {
    _unused: [u8; 0],
}
#[doc = " @struct ov_preprocess_preprocess_steps_t\n @ingroup ov_prepostprocess_c_api\n @brief type define ov_preprocess_preprocess_steps_t from ov_preprocess_preprocess_steps"]
pub type ov_preprocess_preprocess_steps_t = ov_preprocess_preprocess_steps;
#[doc = "!< Undefine color format"]
pub const ov_color_format_e_UNDEFINE: ov_color_format_e = 0;
#[doc = "!< Image in NV12 format as single tensor"]
pub const ov_color_format_e_NV12_SINGLE_PLANE: ov_color_format_e = 1;
#[doc = "!< Image in NV12 format represented as separate tensors for Y and UV planes."]
pub const ov_color_format_e_NV12_TWO_PLANES: ov_color_format_e = 2;
#[doc = "!< Image in I420 (YUV) format as single tensor"]
pub const ov_color_format_e_I420_SINGLE_PLANE: ov_color_format_e = 3;
#[doc = "!< Image in I420 format represented as separate tensors for Y, U and V planes."]
pub const ov_color_format_e_I420_THREE_PLANES: ov_color_format_e = 4;
#[doc = "!< Image in RGB interleaved format (3 channels)"]
pub const ov_color_format_e_RGB: ov_color_format_e = 5;
#[doc = "!< Image in BGR interleaved format (3 channels)"]
pub const ov_color_format_e_BGR: ov_color_format_e = 6;
#[doc = "!< Image in GRAY format (1 channel)"]
pub const ov_color_format_e_GRAY: ov_color_format_e = 7;
#[doc = "!< Image in RGBX interleaved format (4 channels)"]
pub const ov_color_format_e_RGBX: ov_color_format_e = 8;
#[doc = "!< Image in BGRX interleaved format (4 channels)"]
pub const ov_color_format_e_BGRX: ov_color_format_e = 9;
#[doc = " @enum ov_color_format_e\n @ingroup ov_prepostprocess_c_api\n @brief This enum contains enumerations for color format."]
pub type ov_color_format_e = ::std::os::raw::c_uint;
#[doc = "!< linear algorithm"]
pub const ov_preprocess_resize_algorithm_e_RESIZE_LINEAR: ov_preprocess_resize_algorithm_e = 0;
#[doc = "!< cubic algorithm"]
pub const ov_preprocess_resize_algorithm_e_RESIZE_CUBIC: ov_preprocess_resize_algorithm_e = 1;
#[doc = "!< nearest algorithm"]
pub const ov_preprocess_resize_algorithm_e_RESIZE_NEAREST: ov_preprocess_resize_algorithm_e = 2;
#[doc = " @enum ov_preprocess_resize_algorithm_e\n @ingroup ov_prepostprocess_c_api\n @brief This enum contains codes for all preprocess resize algorithm."]
pub type ov_preprocess_resize_algorithm_e = ::std::os::raw::c_uint;
